#!/bin/bash

file=$1

if [ $# -ne 1 ]; then
    echo "$1 should be a valid file." >&2
    exit 1
fi

# get existing max ID, and set first next_id
max_id=$(awk -F';' 'NR > 1 && $1 ~ /^[0-9]+$/ && $1+0 > max { max = $1+0 } END { print max }' "$file")
next_id=$((max_id + 1))

# Transform the format into .tsv
output="${file%.txt}.tsv"

# Clean and transform in one awk block
awk -F';' -v OFS='\t' \
    -v next_id="$next_id" \
    -v non_ascii='[^\x00-\x7F]' '
NR==1 {
    # Header row: remove non-ASCII, trim whitespace
    for (i=1; i<=NF; i++) {
        gsub(non_ascii, "", $i)
        gsub(/^ +| +$/, "", $i)
        printf "%s%s", $i, (i<NF?OFS:ORS)
    }
    next
}

{
    # Remove Windows carriage return
    sub(/\r$/, "")

    # Clean each field: delete non-ASCII, trim spaces, convert decimal commas
    for (i=1; i<=NF; i++) {
        gsub(non_ascii, "", $i)
        gsub(/^ +| +$/, "", $i)
        if ($i ~ /^[0-9]/) {
            gsub(/,/, ".", $i)
        }
    }

    # Normalize comma spacing only in the last two columns
    c1 = NF-1; c2 = NF
    gsub(/ *, */, ",", $c1)
    gsub(/ *, */, ",", $c2)

    # Assign new sequential ID if missing or invalid
    if ($1=="" || $1!~/^[0-9]+$/) {
        $1 = next_id++
    }

    # Output cleaned line as TSV
    for (i=1; i<=NF; i++) {
        printf "%s%s", $i, (i<NF?OFS:ORS)
    }
}
' "$file" > "$output"
